import argparse
import json
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable

import tomllib

CONFIG_FILENAME = "licenses-deny.toml"
ROOT_MARKERS = [
    CONFIG_FILENAME,
    "pyproject.toml",
    "project.toml",
    "requirements.txt",
    "requests.txt",
]

TEMPLATE_CONFIG = """# License allow/deny configuration for this project, generated by licenses-deny.
[licenses]
allow = [
  "MIT",
  "Apache-2.0",
  "BSD-3-Clause",
  "PSF-2.0",
  "CC0-1.0"
]

# If a package metadata license is ambiguous, add a clarification rule
clarify = [
  # { package = "example", license = "MIT", link = "https://example/license" },
]

# Exceptions allow additional licenses for a specific package
exceptions = [
  # { package = "example-special", allow = ["MPL-2.0"] }
]

# Banned dependencies that must not appear in the environment
[bans]
packages = [
  # { name = "leftpad", reason = "Security review failed" },
]

# Non-PyPI sources allowlist (substring match)
[sources]
allow = [
  # "git:https://github.com/example/project",
  # "file:///opt/vendor/wheels",
]
"""

LICENSE_MAPPING = {
    "mit": "MIT",
    "mit license": "MIT",
    "apache 2.0": "Apache-2.0",
    "apache license 2.0": "Apache-2.0",
    "apache license version 2.0": "Apache-2.0",
    "apache software license": "Apache-2.0",
    "apache-2.0": "Apache-2.0",
    "bsd 3-clause": "BSD-3-Clause",
    "bsd-3-clause": "BSD-3-Clause",
    "bsd 3 clause": "BSD-3-Clause",
    "bsd": "BSD",
    "isc": "ISC",
    "mpl-2.0": "MPL-2.0",
    "mozilla public license 2.0": "MPL-2.0",
    "psf": "PSF-2.0",
    "psf license": "PSF-2.0",
    "python software foundation license": "PSF-2.0",
    "cc0-1.0": "CC0-1.0",
    "unlicense": "Unlicense",
    "zlib": "Zlib",
    "public domain": "CC0-1.0",
    "openssl": "OpenSSL",
    "gpl-3.0": "GPL-3.0",
    "gplv3": "GPL-3.0",
    "gpl 3": "GPL-3.0",
    "gnu general public license v3.0": "GPL-3.0",
    "gnu general public license version 3": "GPL-3.0",
    "gpl-2.0": "GPL-2.0",
    "gplv2": "GPL-2.0",
    "gpl 2": "GPL-2.0",
    "gnu general public license v2.0": "GPL-2.0",
    "gnu general public license version 2": "GPL-2.0",
    "lgpl-3.0": "LGPL-3.0",
    "lgplv3": "LGPL-3.0",
    "lgpl 3": "LGPL-3.0",
    "gnu lesser general public license v3.0": "LGPL-3.0",
    "gnu lesser general public license version 3": "LGPL-3.0",
    "lgpl-2.1": "LGPL-2.1",
    "lgplv2.1": "LGPL-2.1",
    "lgpl 2.1": "LGPL-2.1",
    "gnu lesser general public license v2.1": "LGPL-2.1",
    "gnu lesser general public license version 2.1": "LGPL-2.1",
    "agpl-3.0": "AGPL-3.0",
    "agplv3": "AGPL-3.0",
    "agpl 3": "AGPL-3.0",
    "gnu affero general public license v3.0": "AGPL-3.0",
    "gnu affero general public license version 3": "AGPL-3.0",
}
@dataclass
class ClarifyRule:
    package: str
    license: str
    version_op: str | None
    version_val: str | None

    def matches(self, package: str, version: str) -> bool:
        if self.package != package:
            return False
        if self.version_op is None:
            return True
        if self.version_op == "=":
            return self.version_val == version
        return False

@dataclass
class LicenseException:
    package: str
    allow: set[str]
    source: str | None = None


@dataclass
class LicensePolicy:
    allow: set[str] = field(default_factory=set)
    exceptions: list[LicenseException] = field(default_factory=list)
    clarify_rules: list[ClarifyRule] = field(default_factory=list)

@dataclass
class BanRule:
    name: str
    reason: str | None = None

@dataclass
class SourcePolicy:
    allowlist: list[str] = field(default_factory=list)

@dataclass
class Config:
    licenses: LicensePolicy
    bans: list[BanRule]
    sources: SourcePolicy

@dataclass
class SourceInfo:
    label: str
    kind: str

@dataclass
class PackageRecord:
    name: str
    version: str
    raw_license: str
    effective_license: str
    clarified: bool
    source: SourceInfo

def in_virtual_environment() -> bool:
    """Check if running inside a virtual environment."""
    return hasattr(sys, "real_prefix") or (
        hasattr(sys, "base_prefix") and sys.base_prefix != sys.prefix
    )

def find_project_root(start: Path | None = None) -> Path:
    current = start or Path.cwd()
    for path in [current] + list(current.parents):
        if any((path / marker).exists() for marker in ROOT_MARKERS):
            return path
    return current

def locate_config_path() -> Path:
    root = find_project_root()
    candidate = root / CONFIG_FILENAME
    if candidate.is_file():
        return candidate
    raise FileNotFoundError(
        f"Configuration file '{CONFIG_FILENAME}' not found near {root}. "
        "Run `licenses-deny init` to create a template."
    )

def normalize_license(raw: str) -> str:
    if not raw or raw == "Unknown":
        return raw
    normalized = re.sub(r"\s+", " ", raw.strip()).lower()
    mapping = LICENSE_MAPPING
    if normalized in mapping:
        return mapping[normalized]
    if "apache" in normalized and ("2.0" in normalized or "2" in normalized):
        return "Apache-2.0"
    if "mit" in normalized:
        return "MIT"
    if "bsd" in normalized and ("3" in normalized or "three" in normalized or "new" in normalized):
        return "BSD-3-Clause"
    if "lgpl" in normalized:
        if "2.1" in normalized:
            return "LGPL-2.1"
        if "3" in normalized:
            return "LGPL-3.0"
    if "agpl" in normalized and "3" in normalized:
        return "AGPL-3.0"
    if "gpl" in normalized:
        if "3" in normalized:
            return "GPL-3.0"
        if "2" in normalized:
            return "GPL-2.0"
    if "psf" in normalized or "python software foundation" in normalized:
        return "PSF-2.0"
    if "public domain" in normalized:
        return "CC0-1.0"
    return raw.strip()

def summarize_license(value: str, max_len: int = 64) -> str:
    collapsed = re.sub(r"\s+", " ", value or "").strip()
    if len(collapsed) > max_len:
        return collapsed[: max_len - 3] + "..."
    return collapsed

def split_license_expression(expr: str, strict: bool) -> list[str]:
    if not expr or expr == "Unknown":
        return [expr]
    sep_operator = " AND " if strict else " OR "
    cleaned = re.sub(r"[()]", " ", expr)
    cleaned = re.sub(r"[\\/;,\\+]", sep_operator, cleaned)
    if re.search(r"\b(and|or)\b", cleaned, flags=re.IGNORECASE):
        parts = re.split(r"\s+(?:and|or)\s+", cleaned, flags=re.IGNORECASE)
        return [p.strip() for p in parts if p.strip()]
    return [part.strip() for part in cleaned.split(sep_operator) if part.strip()]


def tokenize_license_expression(expr: str, strict: bool) -> list[str]:
    operator_token = "AND" if strict else "OR"
    replaced = re.sub(r"[\\/;,\\+]", f" {operator_token} ", expr)
    tokens: list[str] = []
    pattern = re.compile(r"\(|\)|\bAND\b|\bOR\b|[^()\s]+", flags=re.IGNORECASE)
    for match in pattern.finditer(replaced):
        token = match.group(0)
        upper = token.upper()
        if upper in ("AND", "OR"):
            tokens.append("AND" if (strict and upper == "OR") else upper)
        elif token in ("(", ")"):
            tokens.append(token)
        else:
            tokens.append(token.strip())
    return [t for t in tokens if t]


def to_postfix(tokens: list[str]) -> list[str]:
    output: list[str] = []
    stack: list[str] = []
    precedence = {"AND": 2, "OR": 1}
    for tok in tokens:
        if tok in precedence:
            while stack and stack[-1] in precedence and precedence[stack[-1]] >= precedence[tok]:
                output.append(stack.pop())
            stack.append(tok)
        elif tok == "(":
            stack.append(tok)
        elif tok == ")":
            while stack and stack[-1] != "(":
                output.append(stack.pop())
            if not stack:
                raise ValueError("Mismatched parenthesis in license expression")
            stack.pop()
        else:
            output.append(tok)
    while stack:
        if stack[-1] in ("(", ")"):
            raise ValueError("Mismatched parenthesis in license expression")
        output.append(stack.pop())
    return output


def evaluate_license_postfix(postfix: list[str], allowed_set: set[str], strict: bool) -> bool:
    if not postfix:
        return False
    stack: list[bool] = []
    for tok in postfix:
        if tok in ("AND", "OR"):
            if len(stack) < 2:
                raise ValueError("Invalid license expression")
            right = stack.pop()
            left = stack.pop()
            if tok == "AND" or (strict and tok == "OR"):
                stack.append(left and right)
            else:
                stack.append(left or right)
        else:
            normalized = normalize_license(tok)
            stack.append(normalized in allowed_set)
    if len(stack) != 1:
        return all(stack) if strict else any(stack)
    return bool(stack[0])

def parse_version_spec(spec_str: str) -> tuple[str, str] | None:
    spec = spec_str.strip()
    if spec.startswith("="):
        value = spec[1:].strip()
        if value:
            return "=", value
    return None

def load_config(config_path: Path) -> Config:
    with config_path.open("rb") as fp:
        raw_config = tomllib.load(fp)

    licenses_cfg = raw_config.get("licenses", {}) or {}
    allow = set(licenses_cfg.get("allow", []))
    exceptions: list[LicenseException] = []
    for exc in licenses_cfg.get("exceptions", []):
        pkg = exc.get("package", "")
        allow_list = exc.get("allow", [])
        source_label = exc.get("source")
        if pkg and allow_list:
            exceptions.append(LicenseException(package=pkg.lower(), allow=set(allow_list), source=source_label))

    clarify_rules: list[ClarifyRule] = []
    for entry in licenses_cfg.get("clarify", []):
        pkg = entry.get("package", "")
        license_expr = entry.get("license", "")
        version_spec = entry.get("version", "")
        if not pkg or not license_expr:
            continue
        parsed_spec = parse_version_spec(version_spec) if version_spec else None
        rule = ClarifyRule(
            package=pkg.lower(),
            license=license_expr,
            version_op=parsed_spec[0] if parsed_spec else None,
            version_val=parsed_spec[1] if parsed_spec else None,
        )
        clarify_rules.append(rule)

    bans_cfg = raw_config.get("bans", {}) or {}
    ban_rules: list[BanRule] = []
    for entry in bans_cfg.get("packages", []):
        name = entry.get("name", "")
        reason = entry.get("reason")
        if name:
            ban_rules.append(BanRule(name=name.lower(), reason=reason))

    sources_cfg = raw_config.get("sources", {}) or {}
    allowlist = sources_cfg.get("allow", []) or []

    return Config(
        licenses=LicensePolicy(allow=allow, exceptions=exceptions, clarify_rules=clarify_rules),
        bans=ban_rules,
        sources=SourcePolicy(allowlist=allowlist),
    )

def extract_license_from_metadata(dist) -> str:
    try:
        expr = dist.metadata.get("License-Expression", "").strip()
        if expr:
            return expr
    
        license_field = dist.metadata.get("License", "").strip()
        if license_field and license_field not in ("UNKNOWN", "Other/Proprietary"):
            return license_field
        for classifier in dist.metadata.get_all("Classifier", []):
            if classifier.startswith("License ::"):
                lowered = classifier.lower()
                if "python software foundation license" in lowered:
                    return "PSF-2.0"
                if "mit" in lowered:
                    return "MIT"
                if "apache" in lowered and "2.0" in lowered:
                    return "Apache-2.0"
                if "bsd" in lowered:
                    if "3-clause" in lowered or "three clause" in lowered:
                        return "BSD-3-Clause"
                    return "BSD"
                if "public domain" in lowered:
                    return "Public Domain"
                if "mozilla public license 2.0" in lowered:
                    return "MPL-2.0"
        return "Unknown"
    except Exception:
        return "Unknown"


def resolve_source(dist) -> SourceInfo:
    try:
        direct_url_path: Path | None = None
        files = getattr(dist, "files", None) or []
        for entry in files:
            if entry.name == "direct_url.json":
                candidate = Path(dist.locate_file(entry))
                if candidate.is_file():
                    direct_url_path = candidate
                    break
        if direct_url_path is None:
            candidate = Path(dist.locate_file("direct_url.json"))
            if candidate.is_file():
                direct_url_path = candidate
        if direct_url_path is None:
            return SourceInfo(label="pypi", kind="pypi")

        with direct_url_path.open("r", encoding="utf-8") as fp:
            data = json.load(fp)

        url_field = data.get("url", "") or ""
        if "vcs_info" in data:
            vcs = data["vcs_info"].get("vcs", "vcs")
            ref = data["vcs_info"].get("commit_id") or data["vcs_info"].get("requested_revision", "")
            label = f"{vcs}:{url_field}@{ref}" if ref else f"{vcs}:{url_field}"
            return SourceInfo(label=label, kind="vcs")

        lowered = url_field.lower()
        if url_field.startswith("file://"):
            return SourceInfo(label=url_field, kind="dir")
        if lowered.startswith("git+") or lowered.startswith("ssh://") or lowered.startswith("git@"):
            return SourceInfo(label=url_field, kind="vcs")
        if url_field:
            return SourceInfo(label=url_field, kind="url")

        return SourceInfo(label="pypi", kind="pypi")
    except Exception:
        return SourceInfo(label="unknown", kind="unknown")

def apply_clarify_rules(
    package: str,
    version: str,
    raw_license: str,
    clarify_rules: Iterable[ClarifyRule],
) -> tuple[str, bool]:
    for rule in clarify_rules:
        if rule.matches(package, version):
            return rule.license, True
    return raw_license, False


def resolve_allowed_set(pkg: PackageRecord, config: Config) -> set[str]:
    allowed = set(config.licenses.allow)
    for exc in config.licenses.exceptions:
        if exc.package != pkg.name:
            continue
        if exc.source:
            if exc.source.lower() not in pkg.source.label.lower():
                continue
        allowed |= exc.allow
    return allowed


def is_license_compliant(raw_license: str, allowed_set: set[str], strict: bool) -> bool:
    if raw_license == "Unknown" or not raw_license:
        return False
    try:
        tokens = tokenize_license_expression(raw_license, strict)
        if not any(tok in ("AND", "OR") for tok in tokens):
            return normalize_license(raw_license) in allowed_set
        postfix = to_postfix(tokens)
        return evaluate_license_postfix(postfix, allowed_set, strict)
    except Exception:
        parts = split_license_expression(raw_license, strict)
        normalized = [normalize_license(part) for part in parts]
        if not normalized:
            return False
        if strict:
            return all(part in allowed_set for part in normalized)
        return any(part in allowed_set for part in normalized)

def collect_packages(config: Config) -> list[PackageRecord]:
    if not in_virtual_environment():
        print(
            "Error: This script must be run inside an activated virtual environment.",
            file=sys.stderr,
        )
        sys.exit(1)
    try:
        import importlib.metadata as ilm
    except Exception as exc:
        print(f"Error: unable to access importlib.metadata: {exc}", file=sys.stderr)
        sys.exit(1)

    records: list[PackageRecord] = []
    for dist in ilm.distributions():
        name = dist.metadata.get("Name")
        if not name:
            continue
        package = name.lower()
        version = dist.version
        raw_license = extract_license_from_metadata(dist)
        effective_license, clarified = apply_clarify_rules(
            package, version, raw_license, config.licenses.clarify_rules
        )
        source = resolve_source(dist)
        records.append(
            PackageRecord(
                name=package,
                version=version,
                raw_license=raw_license,
                effective_license=effective_license,
                clarified=clarified,
                source=source,
            )
        )
    records.sort(key=lambda r: r.name)
    return records

def render_package_line(pkg: PackageRecord) -> str:
    license_part = summarize_license(pkg.effective_license)
    if pkg.clarified and pkg.effective_license != pkg.raw_license:
        license_part = f"{summarize_license(pkg.effective_license)} (raw: {summarize_license(pkg.raw_license)})"
    return f"{pkg.name}=={pkg.version} [{license_part}] source={pkg.source.label}"

def check_licenses(packages: list[PackageRecord], config: Config, strict: bool, quiet: bool) -> bool:
    violations: list[str] = []
    if not config.licenses.allow:
        print("Warning: [licenses.allow] is empty. All licenses will be rejected.", file=sys.stderr)
    for pkg in packages:
        allowed_set = resolve_allowed_set(pkg, config)
        compliant = is_license_compliant(pkg.effective_license, allowed_set, strict)
        if compliant:
            if not quiet:
                status = "clarified" if pkg.clarified else "metadata"
                print(f"[ok:{status}] {pkg.name}=={pkg.version} ({summarize_license(pkg.effective_license)})")
            continue
        detail = (
            f"{pkg.name}=={pkg.version} uses unapproved license: "
            f"{summarize_license(pkg.effective_license)} (raw: {summarize_license(pkg.raw_license)})"
            if pkg.effective_license != pkg.raw_license
            else f"{pkg.name}=={pkg.version} uses unapproved license: {summarize_license(pkg.effective_license)}"
        )
        violations.append(detail)
    if violations:
        print("\nLicense policy violation detected:", file=sys.stderr)
        print("-" * 60, file=sys.stderr)
        for line in violations:
            print(f"  {line}", file=sys.stderr)
        return False
    if not quiet:
        print("\nAll dependencies comply with license policy!")
    return True

def check_bans(packages: list[PackageRecord], ban_rules: list[BanRule], quiet: bool) -> bool:
    if not ban_rules:
        if not quiet:
            print("No bans configured; skipping.")
        return True
    banned_map = {rule.name: rule.reason for rule in ban_rules}
    hits = []
    for pkg in packages:
        if pkg.name in banned_map:
            hits.append((pkg, banned_map[pkg.name]))
    if hits:
        print("\nBanned dependencies detected:", file=sys.stderr)
        print("-" * 60, file=sys.stderr)
        for pkg, reason in hits:
            suffix = f" reason: {reason}" if reason else ""
            print(f"  {pkg.name}=={pkg.version}{suffix}", file=sys.stderr)
        return False
    if not quiet:
        print("No banned dependencies found.")
    return True

def is_source_allowed(source: SourceInfo, allowlist: list[str]) -> bool:
    if source.kind == "pypi":
        return True
    if not allowlist:
        return False
    label_lower = source.label.lower()
    return any(allowed.lower() in label_lower for allowed in allowlist)

def check_sources(packages: list[PackageRecord], source_policy: SourcePolicy, quiet: bool) -> bool:
    violations: list[PackageRecord] = []
    for pkg in packages:
        if not is_source_allowed(pkg.source, source_policy.allowlist):
            violations.append(pkg)
    if violations:
        print("\nNon-PyPI sources found (not in allowlist):", file=sys.stderr)
        print("-" * 60, file=sys.stderr)
        for pkg in violations:
            print(f"  {pkg.name}=={pkg.version} source={pkg.source.label}", file=sys.stderr)
        return False
    if not quiet:
        print("All dependencies originate from allowed sources.")
    return True

def list_packages(packages: list[PackageRecord]) -> None:
    for pkg in packages:
        print(render_package_line(pkg))

def handle_init(force: bool) -> None:
    target_dir = find_project_root()
    target_path = target_dir / CONFIG_FILENAME
    if target_path.exists() and not force:
        print(f"Config already exists at {target_path}. Use --force to overwrite.", file=sys.stderr)
        sys.exit(1)
    if target_path.exists() and force:
        print(f"Warning: Overwriting existing config at {target_path}", file=sys.stderr)
    target_dir.mkdir(parents=True, exist_ok=True)
    target_path.write_text(TEMPLATE_CONFIG, encoding="utf-8")
    print(f"Template config written to {target_path}")

def handle_list(config_path: Path) -> None:
    config = load_config(config_path)
    packages = collect_packages(config)
    list_packages(packages)

def handle_check(scope: str, config_path: Path, strict: bool, quiet: bool) -> None:
    config = load_config(config_path)
    packages = collect_packages(config)
    success = True
    if scope in ("all", "licenses"):
        success &= check_licenses(packages, config, strict, quiet)
    if scope in ("all", "bans"):
        success &= check_bans(packages, config.bans, quiet)
    if scope in ("all", "sources"):
        success &= check_sources(packages, config.sources, quiet)
    if not success:
        sys.exit(1)

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Check third-party dependency licenses and sources against allowlists."
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    init_parser = subparsers.add_parser("init", help="Create a template licenses-deny.toml near the project root.")
    init_parser.add_argument("--force", action="store_true", help="Overwrite existing config file if present.")

    subparsers.add_parser("list", help="List dependencies with licenses and sources.")

    check_parser = subparsers.add_parser(
        "check",
        help="Run compliance checks (licenses, bans, sources).",
    )
    check_parser.add_argument(
        "scope",
        nargs="?",
        choices=["all", "licenses", "bans", "sources"],
        default="all",
        help="Which check to run (default: all).",
    )
    check_parser.add_argument(
        "--strict",
        action="store_true",
        help="Treat compound license expressions (AND/OR) as requiring all licenses to be allowed.",
    )
    check_parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress success logs on stdout.",
    )

    return parser

def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    if args.command == "init":
        handle_init(force=args.force)
        return

    try:
        config_path = locate_config_path()
    except FileNotFoundError as exc:
        print(str(exc), file=sys.stderr)
        sys.exit(1)

    if args.command == "list":
        handle_list(config_path)
        return

    if args.command == "check":
        handle_check(scope=args.scope, config_path=config_path, strict=args.strict, quiet=args.quiet)
        return

    parser.error("Unknown command")

if __name__ == "__main__":
    main()
